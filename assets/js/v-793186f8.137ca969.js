"use strict";(self.webpackChunkxiaoteng=self.webpackChunkxiaoteng||[]).push([[4216],{9149:(n,s,e)=>{e.r(s),e.d(s,{data:()=>a});const a={key:"v-793186f8",path:"/python/python_basics/built_in_module/multiprocessing.html",title:"multiprocessing",lang:"en-US",frontmatter:{},excerpt:"",headers:[{level:2,title:"用法",slug:"用法",children:[]}],filePathRelative:"python/python_basics/built_in_module/multiprocessing.md",git:{updatedTime:1631876121e3,contributors:[{name:"maxiaoteng",email:"jizhuwo00@hotmail.com",commits:1}]}}},5042:(n,s,e)=>{e.r(s),e.d(s,{default:()=>r});const a=(0,e(6252).uE)('<h1 id="multiprocessing" tabindex="-1"><a class="header-anchor" href="#multiprocessing" aria-hidden="true">#</a> multiprocessing</h1><p>用来执行python的函数，他启动的进程会重新加载父进程的代码。可以通过Queue、Array、Value等对象来通信。</p><h2 id="用法" tabindex="-1"><a class="header-anchor" href="#用法" aria-hidden="true">#</a> 用法</h2><ol><li><p>普通用法</p><div class="language-Python ext-Python line-numbers-mode"><pre class="language-Python"><code>from multiprocessing import Process\n\ndef p_job(x):\n    ...\n\npros = []\nfor i in range(5):\n    p = Process(target=p_job, args=(i,))\n    p.start()\n    pros.append(p)\n# 先启动子进程，再join，父进程等待\nfor pro in pros:\n    pro.join()\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div></li><li><p>进程池 Pool</p><div class="language-Python ext-Python line-numbers-mode"><pre class="language-Python"><code>from multiprocessing import Pool\nimport os, time, random\n\ndef long_time_task(name):\n    print(&#39;Run task %s (%s)...&#39; % (name, os.getpid()))\n    start = time.time()\n    time.sleep(random.random() * 3)\n    end = time.time()\n    print(&#39;Task %s runs %0.2f seconds.&#39; % (name, (end - start)))\n\nif __name__==&#39;__main__&#39;:\n    print(&#39;Parent process %s.&#39; % os.getpid())\n    p = Pool(4)\n    for i in range(5):\n        p.apply_async(long_time_task, args=(i,))\n    print(&#39;Waiting for all subprocesses done...&#39;)\n    p.close()\n    p.join()\n    print(&#39;All subprocesses done.&#39;)\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div></li></ol>',4),r={render:function(n,s){return a}}}}]);