"use strict";(self.webpackChunkxiaoteng=self.webpackChunkxiaoteng||[]).push([[4051],{8345:(n,s,e)=>{e.r(s),e.d(s,{data:()=>a});const a={key:"v-723ad1df",path:"/python/python_basics/built_in_module/re-model.html",title:"正则表达式",lang:"en-US",frontmatter:{},excerpt:"",headers:[{level:2,title:"元字符()",slug:"元字符",children:[]},{level:2,title:"简单模式",slug:"简单模式",children:[]},{level:2,title:"重复匹配",slug:"重复匹配",children:[]},{level:2,title:"使用正则表达式",slug:"使用正则表达式",children:[]},{level:2,title:"示例",slug:"示例",children:[]}],filePathRelative:"python/python_basics/built_in_module/re-model.md",git:{updatedTime:1631876121e3,contributors:[{name:"maxiaoteng",email:"jizhuwo00@hotmail.com",commits:1}]}}},6675:(n,s,e)=>{e.r(s),e.d(s,{default:()=>i});var a=e(6252);const l=(0,a._)("h1",{id:"正则表达式",tabindex:"-1"},[(0,a._)("a",{class:"header-anchor",href:"#正则表达式","aria-hidden":"true"},"#"),(0,a.Uk)(" 正则表达式")],-1),t={href:"http://wiki.ubuntu.org.cn/Python%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97",target:"_blank",rel:"noopener noreferrer"},r=(0,a.Uk)("参考ubuntu"),p=(0,a.uE)('<div class="language-python ext-py line-numbers-mode"><pre class="language-python"><code><span class="token keyword">import</span> re\n\n<span class="token comment"># 要求从开头匹配</span>\nmatch<span class="token punctuation">(</span>pattern<span class="token punctuation">,</span> string<span class="token punctuation">,</span> flags<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>\n\n<span class="token comment"># 匹配整个文本</span>\nsearch\n\n<span class="token keyword">in</span><span class="token punctuation">:</span> re<span class="token punctuation">.</span>match<span class="token punctuation">(</span><span class="token string">&#39;test&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;test&#39;</span><span class="token punctuation">)</span>\n\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h2 id="元字符" tabindex="-1"><a class="header-anchor" href="#元字符" aria-hidden="true">#</a> 元字符()</h2><ul><li><p><code>.</code> 匹配任意字符</p></li><li><p><code>^</code><br> 在开头使用&#39;^&#39;将匹配类别的补集,比如: [^5]匹配除5之外的任意字符</p></li><li><p><code>$</code></p></li><li><p><code>*</code><br> 字符类中的<code>*</code>并不匹配字符<code>*</code>,而是指定前一个字符可以被匹配零次或更多次</p></li><li><p><code>+</code><br> 和<code>*</code>类似, 只是要求至少要出现一次</p></li><li><p><code>?</code> 用法和<code>*</code> <code>+</code> 类似, 匹配0次或1次</p></li><li><p><code>{</code><code>{m,n}</code>匹配<code>m{2,4}</code>匹配有2个,3个或4个m的字符串, m默认为0,n默认无穷大</p></li><li><p><code>[</code><br><code>&quot;[&quot; 和 &quot;]&quot;</code>用来制定一个字符类别, 比如: <code>[abc]</code>, <code>[a-c]</code>, 将匹配abc的任一字符</p></li><li><p><code>\\</code><br> 后面可加不同的元字符, 来取消元字符功能, 只作为普通字符. 比如: [][\\], 将匹配] [ 和 \\</p></li><li><p><strong>\\d</strong> 匹配任何十进制数；它相当于类 <code>[0-9]</code></p></li><li><p><strong>\\D</strong> 匹配任何非数字字符；它相当于类 <code>[^0-9]</code></p></li><li><p><strong>\\s</strong> 匹配任何空白字符；它相当于类<code>[ \\t\\n\\r\\f\\v]</code></p></li><li><p><strong>\\S</strong> 匹配任何非空白字符；它相当于类 <code>[^ \\t\\n\\r\\f\\v]</code></p></li><li><p><strong>\\w</strong> 匹配任何字母数字字符；它相当于类 <code>[a-zA-Z0-9_]</code></p></li><li><p><strong>\\W</strong> 匹配任何非字母数字字符；它相当于类<code>[^a-zA-Z0-9_]</code> 以上字符集可以包含在字符类中, 比如: <code>[\\s,.]</code> 匹配所有空白字符 , .</p></li><li><p><code>|</code></p></li><li><p><code>(</code></p></li><li><p><code>)</code></p></li></ul><p>注意:</p><ol><li>元字符在类别中不起作用, 比如: [abc$]将匹配&#39;$&#39;, &#39;$&#39;作为普通字符</li></ol><h2 id="简单模式" tabindex="-1"><a class="header-anchor" href="#简单模式" aria-hidden="true">#</a> 简单模式</h2><p>字符匹配, 不定长匹配</p><h2 id="重复匹配" tabindex="-1"><a class="header-anchor" href="#重复匹配" aria-hidden="true">#</a> 重复匹配</h2><p>除了匹配不定长字符集,另一个功能就是可以指定正则表达式的一部分的重复次数</p><h2 id="使用正则表达式" tabindex="-1"><a class="header-anchor" href="#使用正则表达式" aria-hidden="true">#</a> 使用正则表达式</h2><ul><li>编译正则表达式</li></ul><div class="language-python ext-py line-numbers-mode"><pre class="language-python"><code><span class="token keyword">import</span> re\np <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token builtin">compile</span><span class="token punctuation">(</span><span class="token string">&#39;ab*&#39;</span><span class="token punctuation">)</span>\n<span class="token keyword">print</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span>  <span class="token comment"># &lt;_sre.SRE_Pattern object at 0xb76e1a70&gt;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>如果匹配反斜杠, 尽量使用raw字符串, r&#39;\\strt&#39;, r&#39;\\n&#39;表示&#39;&#39;和&#39;n&#39;两个字符, &#39;\\n&#39;表示换行.</p><ul><li>执行匹配 <strong>match()</strong> 决定RE是否在字符串刚开始的位置匹配<br><strong>search()</strong> 扫描字符串, 找到RE匹配的位置<br><strong>findall()</strong> 找到RE匹配的所有子串,并把他们作为一个列表返回<br><strong>finditer()</strong> 找到RE匹配的所有子串,并把他们作为一个迭代器返回</li></ul><blockquote><p>如果没有匹配, march和search返回None, 成功的话,返回MatchObject实例</p></blockquote><ul><li><p>取回结果<br><strong>MatchObject</strong> 有几个方法:</p></li><li><p>group() 返回被RE匹配的字符串</p></li><li><p>start() 返回匹配开始的位置</p></li><li><p>end() 返回匹配结束的位置</p></li><li><p>span() 返回一个元组,包含匹配(开始,结束)的位置</p></li></ul><h2 id="示例" tabindex="-1"><a class="header-anchor" href="#示例" aria-hidden="true">#</a> 示例</h2><ol><li>替换字符串中的换行符</li></ol><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>import re\n# 构造pattern, 使用sub替换, 参数(pattern, &#39;&#39;, str, count, flag)\n# &#39;&#39;用来替换的内容, str是操作的字符串, count数量\npattern = re.compile(r&#39;[\\r\\n]&#39;)\nnew_s = re.sub(pattern, &#39; &#39;, &#39;22222 \\r    33333 \\n   44444 \\r\\n  55555&#39;)\n#  或者直接使用\nnew_s = re.sub(r&#39;[\\r\\n]&#39;, &#39; &#39;, &#39;22222 \\r    33333 \\n   44444 \\r\\n  55555&#39;)\nprint(new_s)\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><ol start="2"><li>分隔字符串</li></ol><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>import re\nre.split(&#39;[_#|]&#39;,&#39;this_is#a|test&#39;)\n&gt;&gt; [&#39;this&#39;, &#39;is&#39;, &#39;a&#39;, &#39;test&#39;]\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ol start="3"><li>使用非贪婪匹配<div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>    import re\n    tags = re.findall(r&quot;mm(.+?)ss&quot;, target_str)\n    # . 匹配所有\n    # + 至少一个\n    # ？ 非贪婪匹配，查找符合条件及停止\n    # mmkhgoiurwss  返回  khgoiurw\n    # 不包含括号，将匹配所有\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div></li></ol>',22),i={render:function(n,s){const e=(0,a.up)("OutboundLink");return(0,a.wg)(),(0,a.iD)(a.HY,null,[l,(0,a._)("p",null,[(0,a._)("a",t,[r,(0,a.Wm)(e)])]),p],64)}}}}]);