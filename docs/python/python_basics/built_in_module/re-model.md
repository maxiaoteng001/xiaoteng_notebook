# 正则表达式

[参考ubuntu](http://wiki.ubuntu.org.cn/Python%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97)

```python
import re

# 要求从开头匹配
match(pattern, string, flags=0)

# 匹配整个文本
search

in: re.match('test', 'test')

```

## 元字符()
- `.`  匹配任意字符
- `^`  
在开头使用'^'将匹配类别的补集,比如: [^5]匹配除5之外的任意字符

- `$`
- `*`  
字符类中的`*`并不匹配字符`*`,而是指定前一个字符可以被匹配零次或更多次

- `+`  
和`*`类似, 只是要求至少要出现一次

- `?`
用法和`*` `+` 类似, 匹配0次或1次

- `{`
`{m,n}`匹配`m{2,4}`匹配有2个,3个或4个m的字符串, m默认为0,n默认无穷大

- `[`   
`"[" 和 "]"`用来制定一个字符类别, 比如: `[abc]`, `[a-c]`, 将匹配abc的任一字符

- `\`   
后面可加不同的元字符, 来取消元字符功能, 只作为普通字符. 比如: [\]\[\\], 将匹配] [ 和 \  
 - **\d**  匹配任何十进制数；它相当于类 `[0-9]`
 - **\D**  匹配任何非数字字符；它相当于类 `[^0-9]`
 - **\s**  匹配任何空白字符；它相当于类`[ \t\n\r\f\v]`
 - **\S**  匹配任何非空白字符；它相当于类 `[^ \t\n\r\f\v]`
 - **\w**  匹配任何字母数字字符；它相当于类 `[a-zA-Z0-9_]`
 - **\W**  匹配任何非字母数字字符；它相当于类`[^a-zA-Z0-9_]`
以上字符集可以包含在字符类中, 比如: `[\s,.]` 匹配所有空白字符 , .

- `|`
- `(`
- `)`

注意: 
1. 元字符在类别中不起作用, 比如: [abc$]将匹配'$', '$'作为普通字符

## 简单模式

字符匹配, 不定长匹配

## 重复匹配

除了匹配不定长字符集,另一个功能就是可以指定正则表达式的一部分的重复次数


## 使用正则表达式

- 编译正则表达式
```python
import re
p = re.compile('ab*')
print(p)  # <_sre.SRE_Pattern object at 0xb76e1a70>
```
如果匹配反斜杠\, 尽量使用raw字符串, r'\strt', r'\n'表示'\'和'n'两个字符, '\n'表示换行. 

- 执行匹配
**match()** 决定RE是否在字符串刚开始的位置匹配  
**search()** 扫描字符串, 找到RE匹配的位置  
**findall()** 找到RE匹配的所有子串,并把他们作为一个列表返回  
**finditer()** 找到RE匹配的所有子串,并把他们作为一个迭代器返回  

> 如果没有匹配, march和search返回None, 成功的话,返回MatchObject实例  

- 取回结果   
**MatchObject** 有几个方法:

 - group() 返回被RE匹配的字符串  
 - start() 返回匹配开始的位置  
 - end()  返回匹配结束的位置  
 - span()  返回一个元组,包含匹配(开始,结束)的位置    
 
 
 ## 示例
 1. 替换字符串中的换行符
 ```
import re
# 构造pattern, 使用sub替换, 参数(pattern, '', str, count, flag)
# ''用来替换的内容, str是操作的字符串, count数量
pattern = re.compile(r'[\r\n]')
new_s = re.sub(pattern, ' ', '22222 \r    33333 \n   44444 \r\n  55555')
#  或者直接使用
new_s = re.sub(r'[\r\n]', ' ', '22222 \r    33333 \n   44444 \r\n  55555')
print(new_s)
```

2. 分隔字符串
```
import re
re.split('[_#|]','this_is#a|test')
>> ['this', 'is', 'a', 'test']
```

3. 使用非贪婪匹配
    ```
        import re
        tags = re.findall(r"mm(.+?)ss", target_str)
        # . 匹配所有
        # + 至少一个
        # ？ 非贪婪匹配，查找符合条件及停止
        # mmkhgoiurwss  返回  khgoiurw
        # 不包含括号，将匹配所有
    ```



